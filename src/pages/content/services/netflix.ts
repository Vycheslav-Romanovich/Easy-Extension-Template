import { updateSubs, updateTranslatedSubs } from '../events'
import { getLanguageName } from '../../../constants/supportedLanguages'
import Subs from '../subs'
import axios from 'axios'

const WEBVTT = 'webvtt-lssdh-ios8'
const SUB_TYPES = {
  closedcaptions: '[cc]',
  subtitles: '',
}

interface Track {
  isNoneTrack: boolean
  isForcedNarrative: boolean
  language: string
  rawTrackType: 'subtitles' | 'closedcaptions'
  languageDescription: string
  ttDownloadables: {
    'webvtt-lssdh-ios8': {
      urls: Record<string, string>
    }
    simplesdh: {
      downloadUrls: Record<string, string>
    }
  }
}

export interface SubsLinksType {
  [key: string]: string
}

class Netflix {
  // eslint-disable-next-line
  private subCache: any
  public isUpdateSubsCache: boolean

  constructor() {
    this.subCache = {}
    this.isUpdateSubsCache = false
    this.processSubData = this.processSubData.bind(this)
    window.addEventListener('elangSubs_data', this.processSubData)
  }

  public init(): void {
    this.injectScript()
    setInterval(() => {
      const videoControlContainer = document.querySelector('.watch-video--bottom-controls-container')
      const eLangSettings = document.querySelector('.elangSubs-settings')
      if (videoControlContainer && !eLangSettings) {
        window.dispatchEvent(new CustomEvent('elangSubsRenderSettings'))
      }
    }, 100)
  }

  // eslint-disable-next-line
  public async getSubs(language: string, locale: string): Promise<Array<SubsLinksType> | undefined> {
    const ccLanguage = language + SUB_TYPES.closedcaptions

    const subsList = this.subCache[this.getMoveId()]

    if (subsList && language) {
      const langKey = Object.keys(subsList).find((key) => !key.includes('-forced') && (key.includes(language) || key === ccLanguage)) || ''
      const subUri = subsList[langKey]?.url ? subsList[langKey].url : ''

      if (langKey && subUri) {
        const { data } = await axios.get(subUri)

        updateSubs({
          url: '',
          synchronized: false,
          videoId: this.getMoveId(),
          languageCode: langKey,
          languageName: getLanguageName(langKey, locale),
          autogenerated: false,
          //@ts-ignore
          text: Subs.ProcessSubs(data),
          isAutoGenerated: false,
        })
      } else {
        updateSubs({
          url: '',
          synchronized: false,
          videoId: null,
          languageCode: null,
          languageName: null,
          autogenerated: null,
          text: null,
          isAutoGenerated: false,
        })
      }
      //@ts-ignore
      const subsListWithLangName: Array<SubsLinksType> | undefined = Object.keys(subsList).map((langCode) => {
        if (!langCode.includes('-forced') && getLanguageName(langCode, locale) !== 'unknown') {
          return {
            langCode: langCode,
            languageDescription: subsList[langCode].languageDescription,
            langName: getLanguageName(langCode, locale) + langCode.substr(2),
            link: subsList[langCode].url,
          }
        }
      })
      const filteredArr = subsListWithLangName?.filter((obj) => obj !== undefined)
      return filteredArr
    }
  }

  // eslint-disable-next-line
  public async getTranslatedSubs(netflixSubsLinks: Array<SubsLinksType> | undefined, languageCode: string) {
    let subUri = ''
    let subObj = undefined

    if (netflixSubsLinks && netflixSubsLinks.length && languageCode) {
      netflixSubsLinks.forEach((subLinkObj) => {
        if (
          subLinkObj.langCode.includes(languageCode) ||
          subLinkObj.langCode === languageCode + '[cc]' ||
          subLinkObj.langCode === languageCode + '[-forced]'
        ) {
          subUri = subLinkObj.link
          subObj = subLinkObj
        }
      })

      const { data } = await axios.get(subUri)

      if (subObj && subUri) {
        updateTranslatedSubs({
          url: '',
          synchronized: false,
          videoId: this.getMoveId(),
          //@ts-ignore
          languageCode: subObj.langCode,
          //@ts-ignore
          languageName: subObj.langName,
          autogenerated: false,
          //@ts-ignore
          text: Subs.ProcessSubs(data),
          isAutoGenerated: false,
        })
      }
      if (!subObj) {
        updateTranslatedSubs({
          url: '',
          synchronized: false,
          videoId: null,
          languageCode: null,
          languageName: null,
          autogenerated: null,
          text: null,
          isAutoGenerated: false,
        })
      }
    }
  }

  private injection = () => {
    const parseMock = JSON.parse
    const stringifyMock = JSON.stringify

    JSON.parse = function() {
      // eslint-disable-next-line
      const data = parseMock.apply(this, arguments as any)

      if (data && data.result && data.result.timedtexttracks) {
        window.dispatchEvent(new CustomEvent('elangSubs_data', { detail: data.result }))
      }
      return data
    }
    // eslint-disable-next-line
    JSON.stringify = function(response: any) {
      // eslint-disable-next-line
      if (!response) return stringifyMock.apply(this, arguments as any)
      // eslint-disable-next-line
      const data = parseMock(stringifyMock.apply(this, arguments as any))

      let modified = false
      if (data && data.params && data.params.showAllSubDubTracks != null) {
        data.params.showAllSubDubTracks = true
        modified = true
      }
      if (data && data.params && data.params.profiles) {
        data.params.profiles.push('webvtt-lssdh-ios8')
        modified = true
      }
      // eslint-disable-next-line
      return modified ? stringifyMock(data) : stringifyMock.apply(this, arguments as any)
    }

    function getPlayer() {
      const videoPlayer = window.netflix.appContext.state.playerApp.getAPI().videoPlayer
      const sessionId = videoPlayer.getAllPlayerSessionIds()[0]

      return videoPlayer.getVideoPlayerBySessionId(sessionId)
    }

    // eslint-disable-next-line
    function handleSeek(event: any) {
      getPlayer().seek(event.detail)
    }

    function playNetflixVideo() {
      const videoPlayer = window.netflix.appContext.state.playerApp.getAPI().videoPlayer
      const sessionId = videoPlayer.getAllPlayerSessionIds()[0]
      videoPlayer.getVideoPlayerBySessionId(sessionId).play()
    }

    function pauseNetflixVideo() {
      const videoPlayer = window.netflix.appContext.state.playerApp.getAPI().videoPlayer
      const sessionId = videoPlayer.getAllPlayerSessionIds()[0]
      videoPlayer.getVideoPlayerBySessionId(sessionId).pause()
    }

    window.addEventListener('elangSubsSeek', handleSeek)
    window.addEventListener('elangPlayNetflixVideo', playNetflixVideo)
    window.addEventListener('elangPauseNetflixVideo', pauseNetflixVideo)
    let flag = false
    window.setInterval(() => {
      const player = getPlayer()

      if (player && document.querySelector('.watch-video--player-view')) {
        if (!window.isLoaded) {
          window.isLoaded = true
          window.dispatchEvent(new CustomEvent('elangSubsVideoReady'))
        }
        if (!player.getTimedTextTrack().bcp47 && !flag) {
          window.dispatchEvent(new CustomEvent('elangSubsSubtitlesChanged', { detail: 'en' }))
          flag = true
        }
        if (window.currentLanguage !== player.getTimedTextTrack().bcp47) {
          window.currentLanguage = player.getTimedTextTrack().bcp47

          window.dispatchEvent(new CustomEvent('elangSubsSubtitlesChanged', { detail: window.currentLanguage }))
        }
      } else {
        window.isLoaded = false
        window.currentLanguage = null
      }
    }, 500)
  }
  // eslint-disable-next-line
  private randomProperty = (obj: any) => {
    const keys = Object.keys(obj)
    // tslint:disable-next-line: no-bitwise
    return obj[keys[(keys.length * Math.random()) << 0]]
  }

  // eslint-disable-next-line
  private processSubData(event: any) {
    if (!['EPISODE', 'MOVIE'].includes(event.detail.viewableType)) {
      return
    }

    if (!this.subCache[event.detail.movieId]) {
      this.subCache[event.detail.movieId] = {}
    }

    const tracks: Track[] = event.detail.timedtexttracks
    for (const track of tracks) {
      if (track.isNoneTrack) {
        continue
      }
      let type = SUB_TYPES[track.rawTrackType]
      if (typeof type === 'undefined') type = `[${track.rawTrackType}]`
      const lang = track.language + type + (track.isForcedNarrative ? '-forced' : '')

      if (Object.keys(track.ttDownloadables).length) {
        this.subCache[event.detail.movieId][lang] = this.randomProperty(track.ttDownloadables[WEBVTT].urls)
      }
      if (!this.subCache[event.detail.movieId][lang]) {
        this.subCache[event.detail.movieId][lang] = {cdn_id: 0, url: ''}
      }
      this.subCache[event.detail.movieId][lang] = {
        languageDescription: lang.includes('cc') ? track.languageDescription + ' (' : track.languageDescription,
        ...this.subCache[event.detail.movieId][lang]
      }
    }
    this.isUpdateSubsCache = !this.isUpdateSubsCache
  }

  private injectScript() {
    const sc = document.createElement('script')
    sc.innerHTML = `(${this.injection.toString()})()`
    document.head.appendChild(sc)
    document.head.removeChild(sc)
  }

  public getMoveId(): string {
    return (document.querySelector('*[data-videoid]') as HTMLElement)?.dataset?.videoid || ''
  }
}

export default Netflix
