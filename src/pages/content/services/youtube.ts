import { updateSubs, updateTranslatedSubs } from '../events'
import { getLanguageName } from '../../../constants/supportedLanguages'
import Subs from '../subs'

class YouTube {
  // eslint-disable-next-line
  private subCache: any
  public videoId: string

  constructor() {
    this.subCache = {}
    this.videoId = ''
    this.processSubData = this.processSubData.bind(this)
    window.addEventListener('eLang_data', this.processSubData)
  }

  public init(): void {
    this.injectScript()
  }

  public async getSubs(langKey: string, learningLang: string, locale: string): Promise<URL | undefined> {
    const videoId = this.getVideoId()
    if (langKey && this.subCache[videoId][langKey]) {
      const urlObject: URL = new URL(this.subCache[videoId][langKey])
      urlObject.searchParams.set('fmt', 'vtt')

      let subUri: string;

      // first method
      // const subUri: string = urlObject.href + '&tlang=' + learningLang

      // second method
      // if(learningLang === 'en') {
      //   subUri = urlObject.href
      // } else {
      //   subUri = urlObject.href + '&tlang=' + learningLang
      // }

      // third method
      // if (langKey === localLanguage) {
      //   subUri = urlObject.href + '&tlang=' + learningLang
      // } else if(learningLang === 'en') {
      //   subUri = urlObject.href
      // } else {
      //   subUri = urlObject.href + '&tlang=' + learningLang
      // }

      if (langKey.includes(learningLang)) {
        subUri = urlObject.href
      } else {
        subUri = urlObject.href + '&tlang=' + learningLang
      }

      const resp = await fetch(subUri)

      const data = await resp.text()

      updateSubs({
        url: '',
        synchronized: false,
        videoId: this.getVideoId(),
        languageCode: langKey,
        languageName: getLanguageName(langKey, locale),
        autogenerated: false,
        text: Subs.ProcessSubs(data),
        isAutoGenerated: subUri.includes('&kind='),
      })

      return urlObject
    }
  }

  public async getTranslatedSubs(urlObject: URL, translateLangKey: string, type: string, locale: string): Promise<void> {
    const videoId = this.getVideoId()
    if (translateLangKey && urlObject) {
      urlObject.searchParams.set('fmt', 'vtt')

      const initialLanguageOfSubtitle = urlObject.searchParams.get('lang')
      let googleTranslateRequired = false

      if(initialLanguageOfSubtitle?.includes(translateLangKey)) {
        urlObject.searchParams.delete('tlang')
      } else {
        urlObject.searchParams.set('tlang', translateLangKey!)
      }

      let respTrans = await fetch(urlObject.href)
      await respTrans
        .text()
        .then((text) => {
          if (text.includes('<!DOCTYPE html>') || text.length <= 0) {
            googleTranslateRequired = true
            return
          }

          type === 'local'
            ? updateTranslatedSubs({
              url: urlObject.href,
              synchronized: false,
              videoId: videoId,
              languageCode: translateLangKey!,
              languageName: getLanguageName(translateLangKey!, locale),
              autogenerated: false,
              text: Subs.ProcessSubs(text),
              isAutoGenerated: urlObject.href.includes('&kind='),
            })
            : updateSubs({
              url: '',
              synchronized: false,
              videoId: this.getVideoId(),
              languageCode: translateLangKey!,
              languageName: getLanguageName(translateLangKey!, locale),
              autogenerated: false,
              text: Subs.ProcessSubs(text),
              isAutoGenerated: urlObject.href.includes('&kind='),
            })
        })
        .catch((e) => console.error(e))
      if (!initialLanguageOfSubtitle || !googleTranslateRequired) return
      urlObject.searchParams.set('tlang', translateLangKey!)
      respTrans = await fetch(urlObject.href)
      await respTrans
        .text()
        .then((text) => {
          if (text.includes('<!DOCTYPE html>')) {
            console.error('GT unable to get original local subs')
            return
          }

          type === 'local'
            ? updateTranslatedSubs({
              url: urlObject.href,
              synchronized: false,
              videoId: videoId,
              languageCode: translateLangKey!,
              languageName: getLanguageName(translateLangKey!, locale),
              autogenerated: false,
              text: Subs.ProcessSubs(text),
              isAutoGenerated: urlObject.href.includes('&kind='),
            })
            : updateSubs({
              url: '',
              synchronized: false,
              videoId: this.getVideoId(),
              languageCode: translateLangKey!,
              languageName: getLanguageName(translateLangKey!, locale),
              autogenerated: false,
              text: Subs.ProcessSubs(text),
              isAutoGenerated: urlObject.href.includes('&kind='),
            })
        })
        .catch((e) => console.error(e))
    }
  }

  public getVideoId(): string {
    const regExpression = /^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/
    const match = window.location.href.match(regExpression)
    if (match && match[2].length === 11) {
      return match[2]
    }
    return ''
  }

  private injection = () => {
    window.setInterval(() => {
      // eslint-disable-next-line
      const player: any = document.getElementById('movie_player')
      const subsToggleElement = document.querySelector('.ytp-subtitles-button')

      if (player) {
        if (!window.isLoaded) {
          window.isLoaded = true

          window.dispatchEvent(new CustomEvent('eLangSubsVideoReady'))
          window.dispatchEvent(new CustomEvent('eLangSubsRenderSettings'))

          if (subsToggleElement && subsToggleElement.getAttribute('aria-pressed') === 'false') {
            player.toggleSubtitles()

          } else {
            window.dispatchEvent(new CustomEvent('eLangSubsChanged', { detail: '' }))
          }
        }
      } else {
        window.isLoaded = false
      }
    }, 500)
    ;((open) => {
      XMLHttpRequest.prototype.open = function (method: string, url: string) {
        if (url.match(/^http/g) !== null) {
          const urlObject = new URL(url)
          if (urlObject.pathname === '/api/timedtext') {
            window.subtitlesEnabled = true
            const lang = urlObject.searchParams.get('lang') || urlObject.searchParams.get('tlang')
            window.dispatchEvent(new CustomEvent('eLang_data', { detail: urlObject.href }))
            window.dispatchEvent(new CustomEvent('eLangSubsChanged', { detail: lang }))
          }
        }
        open.call(this, method, url, true)
      }
    })(XMLHttpRequest.prototype.open)
  }
  // eslint-disable-next-line
  private processSubData(event: any): void {
    const urlObject = new URL(event.detail)
    const lang = urlObject.searchParams.get('tlang') || urlObject.searchParams.get('lang')
    // const videoId = urlObject.searchParams.get('v') || ''
    const videoId = this.getVideoId()
    this.subCache[videoId] = {}
    if (lang) {
      this.subCache[videoId][lang] = urlObject.href
    }
  }

  private injectScript(): void {
    const sc = document.createElement('script')
    sc.innerHTML = `(${this.injection.toString()})()`
    document.head.appendChild(sc)
    document.head.removeChild(sc)
  }
}

export default YouTube
