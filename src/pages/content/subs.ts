import { SubtitleLine } from '../../constants/types'
import { fromVtt } from 'subtitles-parser-vtt'
import { cleanUpText, removeDuplicate } from '../../utils/text'
import { updateSubs, updateTranslatedSubs } from './events'

const getArrayLength = (array: any) => {
  let totalCount = 0
  for (let index = 0; index < array.length; index++) {
    if (index in array) {
      totalCount++
    }
  }
  return totalCount
}

class Subs {
  public static clearSubs(): void {
    updateSubs({
      url: '',
      synchronized: false,
      videoId: null,
      languageCode: null,
      languageName: null,
      autogenerated: null,
      text: null,
      isAutoGenerated: false,
    })

    updateTranslatedSubs({
      url: '',
      synchronized: false,
      videoId: null,
      languageCode: null,
      languageName: null,
      autogenerated: null,
      text: null,
      isAutoGenerated: false,
    })
  }
  public static ProcessSubs(text: string): SubtitleLine[] {
    let data = fromVtt(text, 'ms')

    data = data.map((subtitle) => ({
      ...subtitle,
      text: cleanUpText(subtitle.text),
    }))

    data = removeDuplicate(data)

    const syncData = data.map((subI, i) => {
      let countRepeatSubs = 0

      data.forEach((subJ) => {
        if (subI.startTime === subJ.startTime && subI.id !== subJ.id) {
          subI.text = subI.text + ' ' + subJ.text
          countRepeatSubs++
        }
      })

      data.splice(i, countRepeatSubs)

      subI.id = i + 1
      return subI
    })

    return syncData
  }

  public static syncSubs(subs1: SubtitleLine[], subs2: SubtitleLine[]): Array<Array<SubtitleLine>> {
    // смотреть по верхнему субтитру, подгонять нижний субтитр по премени верхнего
    // let needRerun: boolean
    // do {
    //   needRerun = false
    //   subs1.forEach((sub1, i) => {

          // if (sub1.text[0] === '[' && sub1.text[sub1.text.length - 1] === ']') {
          //   const item = subs2.find((item, index) => index + 1 <= subs2.length - 1 && Math.round(item.startTime / 1000) * 1000 <= Math.round(sub1.startTime / 1000) * 1000 && Math.round(subs2[index + 1].startTime / 1000) * 1000 > Math.round(sub1.endTime / 1000) * 1000)
          //   // subs2.splice(i, )
          //   console.log('item', item)
          //   if(item) {
          //      subs2.splice(item.id, 0, {id: item.id + 1, startTime: sub1.startTime, endTime: sub1.endTime, text: '-'})
          //   }
           
          // }
          // if (sub1.startTime > sub2.startTime && sub1.endTime <= sub2.endTime) {
          //   if (i <= 1) return
          //   needRerun = true

          //   subs1.splice(i, 1)
          //   subs1[i - 1].text = subs1[i - 1].text + ' ' + sub1.text
          //   subs1[i - 1].endTime = sub1.endTime
          // }

          // if (sub1.endTime < sub2.endTime && subs1[i + 1].startTime < sub2.endTime) {
          //   subs2.splice(j + 1, 0, { id: j + 1, startTime: subs1[i + 1].startTime, endTime: subs1[i + 1].endTime, text: sub2.text })
          // }
    //   })
    // } while (needRerun)

    // subs1.forEach((element, index1) => {
    //   if (element.text[0] === '[' && element.text[element.text.length - 1] === ']') {
    //     console.log('???', element.text)
    //     subs2.forEach((item, index2) => {
    //       if(element.startTime >= item.startTime && element.endTime <= item.endTime) {
    //         console.log('item')
    //         subs2.splice(index2, 0, { id: index2, startTime: element.startTime, endTime: element.endTime, text: '-' })
    //       } else {
    //         //subs2.splice(index2, 0, { id: index2, startTime: element.startTime, endTime: element.endTime, text: '-' })
    //       }
    //     })
    //   }
    // })

    // subs1.forEach((sub1, index1) => {
    //   subs2.forEach((sub2, index2) => {
    //     // if (sub2 && sub1 && index2 + 1 <= subs2.length - 1) {
    //     //   if (sub1.endTime > sub2.endTime && sub1.endTime === subs2[index2 + 1].endTime) {
    //     //     console.log('items', sub1, sub2, subs2[index2 + 1])
    //     //   }
    //     // }
    //     if(sub1.startTime === sub2.startTime) {
    //       console.log('sub1', sub1, sub2)
    //     }
    //   })
    // })

    const subs2Result = subs2.map((item) => {
      item.startTime = Math.round(item.startTime / 100) * 100
      item.endTime = Math.round(item.endTime / 100) * 100

      return item
    })

    const subs1Result = subs1.map((item) => {
      item.startTime = Math.round(item.startTime / 100) * 100
      item.endTime = Math.round(item.endTime / 100) * 100
      return item
    })

    // const a = subs1Result.map(((item, index) => {
    //   if(index < 7) {
    //     console.log('subs2Result[index].startTime', subs2Result[index].startTime)
    //     console.log('item.startTime', item.startTime)
    //     console.log('subs2Result[index].endTime', subs2Result[index].endTime)
    //     console.log('tem.endTime', item.endTime)
    //     console.log(' subs1Result[index + 1].endTime',  subs1Result[index + 1].endTime)
    //     console.log('item', item)

    //   }
    //   if(index <= subs2Result.length - 1 && (subs2Result[index].startTime <= item.startTime && subs2Result[index].endTime > item.endTime && subs1Result[index + 1].endTime === subs2Result[index].endTime) ) {
    //    console.log('item', item)
    //     return item
    //   }
    //   return item
    // }))

    // console.log('a', a)

    // console.log('return', subs1, subs2)

    return [subs1Result, subs2Result]
  }

  public static getCurrentSubs(video: HTMLVideoElement, subs: SubtitleLine[]): SubtitleLine[] {
    const currentTime = this.getCurrentTime(video)
    const currentSubs = this.getAllCurrentSub(subs, currentTime)
    const nextSubtitle = this.getNextSub(video, subs)

    currentSubs.forEach((sub) => {
      if (nextSubtitle[0]) {
        //@ts-ignore
        const timeDifference = nextSubtitle[0].startTime - sub.endTime
        sub.endTime += timeDifference - 1
      }
    })
    if (currentSubs[0] && currentSubs[0].id === getArrayLength(subs)) {
      currentSubs[0].endTime = Math.floor(video.duration * 1000)
    }

    return currentSubs.map((sub: SubtitleLine) => sub || null)
  }

  private static getCurrentTime(video: HTMLVideoElement) {
    return Math.round(video.currentTime * 1000)
  }

  private static getAllCurrentSub(subs: SubtitleLine[], currentTime: number) {
    return subs.filter((sub: SubtitleLine) => {
      return sub.startTime <= currentTime && sub.endTime >= currentTime
    })
  }

  public static getPreviousSub(video: HTMLVideoElement, subs: SubtitleLine[]) {
    const currentTime = this.getCurrentTime(video)

    let previousSub
    subs.map((sub: SubtitleLine, index) => {
      if (sub.startTime <= currentTime && sub.endTime >= currentTime && subs[index - 1]) {
        previousSub = subs[index - 1]
      }
    })

    return [previousSub]
  }

  public static getNextSub(video: HTMLVideoElement, subs: SubtitleLine[]) {
    const currentTime = this.getCurrentTime(video)

    let nextSub
    subs.map((sub: SubtitleLine, index) => {
      if (sub.startTime <= currentTime && sub.endTime >= currentTime && subs[index + 1]) {
        nextSub = subs[index + 1]
      }
    })

    return [nextSub]
  }
}

export default Subs
